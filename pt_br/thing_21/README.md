# Faça distinção entre exceções de negócio e exceções técnicas

Existem basicamente duas razões para as coisas darem errado em execução: problemas técnicos que nos impede de usar a aplicação e lógica de negócio que evita que abusemos da aplicação. A maioria das linguagens modernas, como LISP, Java, Smalltalk e C#, usam exceções para sinalizar ambas situações. Entretanto, essas duas situações são tão diferentes que elas deveriam ser cuidadosamente mantidas separadas. É fonte potencial de confusão representar ambas usando a mesma hierarquia de exceções e ainda pior se usar a mesma classe de exceção.

Um problema técnico não solucionável pode acontecer quando existe um erro de programação. Por exemplo, se tentar acessar o elemento 83 de um vetor com tamanho 17, o programa estará claramente descontrolado e alguma exceção deve ser lançada. Uma versão mais sutil é chamar código de uma biblioteca com argumentos inapropriados, provocando a mesma situação dentro da biblioteca.

Seria um grande erro tentar resolver essas situações auto-inflingidas. Ao invés disso, nós deixamos a exceção subir até o mais alto nível arquitetural e um mecanismo genérico de tratamento de exceção fará o necessário para garantir que o sistema está num estado seguro, tal como o roll back de uma transação, registrar log e alertar a administração e relatar a situação de volta para o usuário, de forma gentil.

Uma variante dessa situação ocorre quando você está na situação da biblioteca e o chamador quebrou o contrato do seu método, e.g. passando um argumento totalmente bizarro ou não configurando um objecto dependente apropriadamente. Isso é bem parecido com o elemento 83º de um vetor com 17 elementos: o chamador deveria ter checado; não fazer a checagem é um erro do programador do lado do cliente. A resposta adequada é lançar uma exceção técnica.

Uma situação diferente, mas ainda técnica, acontece quando o programa não pode avançar por causa de um problema no ambiente de execução, tal qual um banco de dados que não responde. Nessa situação você deve assumir que a infraestrutura fez o possível para resolver a situação - reparando a conexão e tentando um certo número de vezes - e então falhado definitivamente. Mesmo que a causa seja diferente, a situação para o código que está chamando é similar: existe pouco que possa ser feito sobre isso. Então, nós sinalizamos a situação através de uma exceção e deixamos ela subir a pilha até ser capturada num mecanismo de tratamento de exceção genérico.

Diferente dos exemplos anteriores, nós temos a situação onde você não pode completar uma chamada devido à uma razão lógica do domínio. Nesse caso, nós encontramos uma situação que existe uma exceção, ou seja, não usual e indesejável, mas não é bizarra ou programaticamente errada. Por exemplo, se eu tentar sacar dinheiro de uma conta com fundos insuficientes. Em outras palavras, esse tipo de situação é uma parte do contrato, e lançar uma exceção é apenas um *caminho de retorno alternativo* que é parte do modelo e que o cliente deve estar ciente e preparado para tratar. Para essas situações é apropriado criar uma excepção específica ou uma hierarquia separada de exceções de forma que o cliente possa tratar da situação nos seus próprios termos.

Misturar exceções técnicas e exceções de negócio na mesma hierarquia torna difusa a distinção e confunde o chamador sobre quais os contratos do método, quais condições são exigidas e quais situações são esperadas de serem tratadas. Separar os casos traz clareza e aumenta a chance que as exceções técnicas sejam tratadas pelo framework da aplicação, enquanto que as exceções do domínio de negócio são consideradas e tratadas pelo código do cliente.

Por [Dan Bergh Johnsson](http://programmer.97things.oreilly.com/wiki/index.php/Dan_Bergh_Johnsson)